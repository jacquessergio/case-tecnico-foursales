# Guia de Rate Limiting - E-commerce Foursales

## üìã Vis√£o Geral

O sistema implementa rate limiting usando **Bucket4j** com estrat√©gia de **Token Bucket**, protegendo todos os endpoints da API contra:
- ‚úÖ Ataques DDoS
- ‚úÖ For√ßa bruta em autentica√ß√£o
- ‚úÖ Scraping de dados
- ‚úÖ Abuso de recursos (Elasticsearch, MySQL, Kafka)
- ‚úÖ Enumera√ß√£o de pedidos

---

## üîß Configura√ß√£o de Limites por Endpoint

### 1. **Endpoints P√∫blicos** (100 req/min por IP)
```
GET  /api/v1/products
GET  /api/v1/products/{id}
GET  /api/v1/products?page=0&size=20
```

**Estrat√©gia:** Limita por **IP** (mesmo sem autentica√ß√£o)

**Cen√°rio protegido:**
- Bot fazendo scraping de cat√°logo
- Crawler excessivo
- Ataque de enumera√ß√£o de produtos

---

### 2. **Endpoints de Autentica√ß√£o** (5 req/min por IP) üî¥ CR√çTICO
```
POST /api/v1/auth/login
POST /api/v1/auth/register
```

**Estrat√©gia:** Limita por **IP** (antes da autentica√ß√£o)

**Cen√°rio protegido:**
- For√ßa bruta de senhas
- Cria√ß√£o massiva de contas
- Tentativa de descobrir usu√°rios v√°lidos

**Exemplo de ataque bloqueado:**
```bash
# Atacante tenta 100 senhas
for i in {1..100}; do
  curl -X POST http://localhost:8080/api/v1/auth/login \
    -H "Content-Type: application/json" \
    -d "{\"email\":\"admin@foursales.com\",\"password\":\"senha$i\"}"
done

# Resultado:
# Requisi√ß√µes 1-5: Testadas normalmente
# Requisi√ß√£o 6+: HTTP 429 Too Many Requests
```

---

### 3. **Endpoints de Pedidos** (30 req/min por usu√°rio)
```
POST /api/v1/orders
POST /api/v1/orders/{id}/pay
GET  /api/v1/orders
GET  /api/v1/orders/{id}
```

**Estrat√©gia:** Limita por **User ID** (ap√≥s autentica√ß√£o)

**Cen√°rio protegido:**
- Usu√°rio criando pedidos em massa (DoS)
- Bot automatizado fazendo compras fraudulentas
- Reserva maliciosa de estoque

---

### 4. **Endpoints de Busca** (60 req/min por IP)
```
GET  /api/v1/products/search?nome=notebook
GET  /api/v1/products/search?categoria=eletronicos
GET  /api/v1/products/search/advanced?precoMin=100&precoMax=500
```

**Estrat√©gia:** Limita por **IP**

**Cen√°rio protegido:**
- Queries excessivas no Elasticsearch (CARO!)
- Scraping de produtos por categoria
- Sobrecarga do cluster Elasticsearch

**Custo evitado:**
```
Sem rate limiting:
- Bot: 1000 req/min √ó 60 min = 60.000 queries/hora
- Custo Elasticsearch: ~$0.10 por 1000 queries = $6/hora = $144/dia

Com rate limiting (60 req/min):
- M√°ximo: 60 √ó 60 = 3.600 queries/hora
- Custo: $0.36/hora = $8.64/dia
- ECONOMIA: $135/dia = $4.050/m√™s üí∞
```

---

### 5. **Endpoints Admin** (60 req/min por admin)
```
POST   /api/v1/products
PUT    /api/v1/products/{id}
DELETE /api/v1/products/{id}
```

**Estrat√©gia:** Limita por **User ID** (apenas admin autenticado)

**Cen√°rio protegido:**
- Admin comprometido fazendo opera√ß√µes em massa
- Script automatizado deletando produtos
- Prote√ß√£o contra insider threat

---

### 6. **Endpoints de Relat√≥rios** (10 req/min por admin) üî¥ CR√çTICO
```
GET /api/v1/reports/top-users
GET /api/v1/reports/average-ticket
GET /api/v1/reports/current-month-revenue
```

**Estrat√©gia:** Limita por **User ID** (apenas admin)

**Cen√°rio protegido:**
- Queries complexas com JOIN e agrega√ß√£o
- Sobrecarga do banco de dados
- Mesmo admin pode causar DoS involunt√°rio

**Por que limitar admin?**
```sql
-- Query de relat√≥rio pode levar 5-10 segundos
SELECT u.id, u.name, COUNT(o.id) as order_count
FROM users u
JOIN orders o ON u.id = o.user_id
GROUP BY u.id
ORDER BY COUNT(o.id) DESC;

-- Admin fazendo 100 requisi√ß√µes simult√¢neas:
-- = 100 conex√µes no pool (MAX: 100)
-- = Pool esgotado = SISTEMA INDISPON√çVEL para todos!
```

---

## üìä Testando Rate Limiting

### Teste 1: Endpoint P√∫blico (100 req/min)

```bash
# Fazer 105 requisi√ß√µes rapidamente
for i in {1..105}; do
  echo "Request $i:"
  curl -s -o /dev/null -w "HTTP %{http_code}\n" \
    http://localhost:8080/api/v1/products
done

# Resultado esperado:
# Requests 1-100: HTTP 200
# Requests 101-105: HTTP 429 (Rate limit exceeded)
```

**Headers de resposta (requisi√ß√£o 100):**
```
X-RateLimit-Limit: 100
X-RateLimit-Remaining: 0
X-RateLimit-Reset: 1735987200000
```

**Headers de resposta (requisi√ß√£o 101 - bloqueada):**
```
HTTP/1.1 429 Too Many Requests
Retry-After: 60
X-RateLimit-Limit: 100
X-RateLimit-Remaining: 0
X-RateLimit-Reset: 1735987200000

{
  "code": 429,
  "message": "Rate limit exceeded",
  "stackTrace": "Too many requests. Limit: 100 requests per 60 seconds. Please try again later.",
  "path": "/api/v1/products",
  "timestamp": "2025-10-04T14:30:00"
}
```

---

### Teste 2: Login (5 req/min) - Prote√ß√£o Brute Force

```bash
# Script de brute force (tentando 10 senhas)
for i in {1..10}; do
  echo "Tentativa $i:"
  curl -X POST http://localhost:8080/api/v1/auth/login \
    -H "Content-Type: application/json" \
    -d "{\"email\":\"admin@foursales.com\",\"password\":\"senha$i\"}" \
    -w "HTTP %{http_code}\n"
  sleep 0.5
done

# Resultado esperado:
# Tentativas 1-5: HTTP 401 (Unauthorized - senha incorreta)
# Tentativas 6-10: HTTP 429 (Too Many Requests - bloqueado!)
```

**Logs do servidor (request 6):**
```
WARN  [RateLimitFilter] Rate limit exceeded for ip:192.168.1.100 - Path: /api/v1/auth/login, Type: AUTH
```

---

### Teste 3: Cria√ß√£o de Pedidos (30 req/min por usu√°rio)

```bash
# Login primeiro
TOKEN=$(curl -X POST http://localhost:8080/api/v1/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"user@test.com","password":"password123"}' \
  | jq -r '.token')

# Tentar criar 35 pedidos
for i in {1..35}; do
  echo "Order $i:"
  curl -X POST http://localhost:8080/api/v1/orders \
    -H "Authorization: Bearer $TOKEN" \
    -H "Content-Type: application/json" \
    -d '{
      "items": [
        {"productId": "uuid-produto-1", "quantity": 1}
      ]
    }' \
    -w "HTTP %{http_code}\n"
done

# Resultado esperado:
# Orders 1-30: HTTP 201 (Created)
# Orders 31-35: HTTP 429 (Too Many Requests)
```

---

### Teste 4: Diferentes IPs (rate limiting independente)

```bash
# IP 1 faz 100 requisi√ß√µes
curl http://localhost:8080/api/v1/products  # OK (IP: 192.168.1.100)

# IP 2 tamb√©m consegue fazer 100 requisi√ß√µes (bucket diferente)
curl -H "X-Forwarded-For: 192.168.1.200" \
  http://localhost:8080/api/v1/products  # OK (IP: 192.168.1.200)
```

**Rate limiting √© isolado por chave!**
- `ip:192.168.1.100:PUBLIC` ‚Üí bucket separado
- `ip:192.168.1.200:PUBLIC` ‚Üí bucket separado
- `user:uuid-123:USER` ‚Üí bucket separado

---

## üõ†Ô∏è Endpoints de Administra√ß√£o

### Ver Configura√ß√£o de Limites
```bash
curl http://localhost:8080/api/v1/admin/rate-limit/config \
  -H "Authorization: Bearer $ADMIN_TOKEN" | jq

# Resposta:
{
  "PUBLIC": {
    "limit": 100,
    "window": "1 minute",
    "description": "Public endpoints (product listing, search)"
  },
  "AUTH": {
    "limit": 5,
    "window": "1 minute",
    "description": "Authentication endpoints (login, register)"
  },
  ...
}
```

### Ver Estat√≠sticas do Cache
```bash
curl http://localhost:8080/api/v1/admin/rate-limit/stats \
  -H "Authorization: Bearer $ADMIN_TOKEN" | jq

# Resposta:
{
  "cacheStats": "Rate Limit Cache - Size: 1523, Hit Rate: 94.32%",
  "status": "active"
}
```

### Limpar Todos os Buckets (resetar limites)
```bash
curl -X POST http://localhost:8080/api/v1/admin/rate-limit/clear \
  -H "Authorization: Bearer $ADMIN_TOKEN" | jq

# Resposta:
{
  "message": "All rate limit buckets cleared successfully"
}
```

---

## üìà Monitoramento e Alertas

### Logs de Rate Limit Exceeded

```
2025-10-04 14:30:00 WARN  [RateLimitFilter] Rate limit exceeded for ip:192.168.1.100 - Path: /api/v1/auth/login, Type: AUTH
2025-10-04 14:30:05 WARN  [RateLimitFilter] Rate limit exceeded for user:uuid-123 - Path: /api/v1/orders, Type: USER
```

### M√©tricas para Grafana/Prometheus

**Adicionar contadores customizados:**
```java
// No RateLimitService
@Autowired
private MeterRegistry meterRegistry;

public boolean tryConsume(String key, RateLimitType rateLimitType) {
    boolean consumed = bucket.tryConsume(1);

    if (!consumed) {
        meterRegistry.counter("rate_limit.exceeded",
            "type", rateLimitType.name()).increment();
    }

    return consumed;
}
```

---

## üîç Troubleshooting

### Problema: "Estou sendo bloqueado mesmo com poucas requisi√ß√µes"

**Causa:** Voc√™ pode estar compartilhando IP (NAT, proxy)

**Solu√ß√£o:** Autenticar-se para ter limite baseado em User ID
```bash
# Antes (limitado por IP compartilhado):
curl http://localhost:8080/api/v1/products  # Pode atingir limite r√°pido

# Depois (limitado por seu usu√°rio):
curl -H "Authorization: Bearer $TOKEN" \
  http://localhost:8080/api/v1/products  # Limite independente
```

---

### Problema: "Rate limit n√£o est√° funcionando"

**Verificar:**
1. Filtro est√° registrado no SecurityConfig?
2. Bucket4j est√° no classpath? (`mvn dependency:tree | grep bucket4j`)
3. Logs mostram rate limit warnings?

**Debug:**
```bash
# Ativar logs debug
# application.yml
logging:
  level:
    com.foursales.ecommerce.ratelimit: DEBUG
```

---

## üöÄ Ajustando Limites para Produ√ß√£o

### Cen√°rios de Ajuste

**E-commerce pequeno (<1000 usu√°rios):**
```java
PUBLIC(100, Duration.ofMinutes(1))   // OK
AUTH(5, Duration.ofMinutes(1))       // OK
USER(30, Duration.ofMinutes(1))      // OK
```

**E-commerce m√©dio (1000-10000 usu√°rios):**
```java
PUBLIC(200, Duration.ofMinutes(1))   // Aumentar
AUTH(10, Duration.ofMinutes(1))      // Aumentar (mas cuidado!)
USER(50, Duration.ofMinutes(1))      // Aumentar
SEARCH(100, Duration.ofMinutes(1))   // Aumentar
```

**E-commerce grande (>10000 usu√°rios):**
```java
// Considerar implementar rate limiting distribu√≠do (Redis)
// Bucket4j suporta Redis como backend
```

---

## ‚ö†Ô∏è Considera√ß√µes de Seguran√ßa

### Bypass de Rate Limiting (preven√ß√£o)

**‚ùå N√£o confiar apenas em IP:**
```
Atacante pode rotacionar IPs (VPN, proxies, botnets)
Solu√ß√£o: Rate limiting combinado (IP + User + Session)
```

**‚ùå N√£o remover rate limiting de admin:**
```
Admin comprometido = maior poder de ataque
Solu√ß√£o: Manter limites mesmo para admin (mas mais altos)
```

**‚úÖ Rate limiting √© primeira linha de defesa:**
```
Rate Limiting ‚Üí WAF ‚Üí Load Balancer ‚Üí Application
```

---

## üìö Arquitetura da Solu√ß√£o

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                   HTTP Request                       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚îÇ
                     ‚ñº
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚îÇ   RateLimitFilter     ‚îÇ ‚óÑ‚îÄ‚îÄ Executa ANTES de tudo
         ‚îÇ   (OncePerRequestFilter)‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚îÇ
                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                ‚îÇ Allowed? ‚îÇ
                ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îò
                   ‚îÇ   ‚îÇ
              YES  ‚îÇ   ‚îÇ  NO
                   ‚îÇ   ‚îÇ
                   ‚îÇ   ‚îî‚îÄ‚îÄ‚ñ∫ HTTP 429 + Retry-After
                   ‚îÇ         + Rate limit headers
                   ‚ñº
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚îÇ JwtAuthenticationFilter‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚îÇ
                     ‚ñº
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚îÇ   Security Filters    ‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚îÇ
                     ‚ñº
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚îÇ      Controller       ‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Componentes

1. **RateLimitType** (Enum)
   - Define limites por tipo de endpoint
   - Retorna configura√ß√£o Bandwidth

2. **RateLimitService** (Service)
   - Gerencia buckets usando Caffeine Cache
   - Cache de 100k buckets, expira ap√≥s 10min inatividade
   - M√©todos: `tryConsume()`, `getRemainingTokens()`

3. **RateLimitKeyResolver** (Component)
   - Resolve chave √∫nica: `ip:x.x.x.x` ou `user:uuid`
   - Extrai IP considerando proxies (X-Forwarded-For)
   - Determina tipo de rate limit baseado no path

4. **RateLimitFilter** (Filter)
   - Intercepta requisi√ß√µes ANTES de autentica√ß√£o
   - Adiciona headers informativos (X-RateLimit-*)
   - Retorna 429 com Retry-After quando excedido

5. **RateLimitController** (Controller)
   - Endpoints admin para monitoramento
   - Estat√≠sticas do cache
   - Limpar buckets manualmente

---

## ‚úÖ Checklist de Implementa√ß√£o

- [x] Depend√™ncia Bucket4j adicionada
- [x] Enum RateLimitType criado com 6 tipos
- [x] RateLimitService implementado com Caffeine
- [x] RateLimitKeyResolver para IP e User
- [x] RateLimitFilter integrado ao SecurityFilterChain
- [x] Headers X-RateLimit-* adicionados
- [x] Retry-After header em 429 responses
- [x] Endpoints admin para monitoramento
- [x] Logs de warning quando limite excedido
- [x] Constantes movidas para AppConstants

---

## üéØ Resultados Esperados

**Antes do Rate Limiting:**
- ‚ùå Vulner√°vel a DDoS
- ‚ùå For√ßa bruta em login ilimitada
- ‚ùå Bots podem scraper todo cat√°logo
- ‚ùå Custos de infra imprevis√≠veis
- ‚ùå Sistema pode cair por abuso

**Depois do Rate Limiting:**
- ‚úÖ Prote√ß√£o contra DDoS (IP-based)
- ‚úÖ Brute force limitado a 5 tentativas/min
- ‚úÖ Bots limitados a 100 req/min
- ‚úÖ Custos previs√≠veis e controlados
- ‚úÖ Sistema est√°vel mesmo sob ataque

---

**Data:** 2025-10-04
**Vers√£o:** 1.0.0
**Autor:** Claude Code
