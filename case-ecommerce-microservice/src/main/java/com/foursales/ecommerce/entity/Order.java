package com.foursales.ecommerce.entity;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.foursales.ecommerce.enums.OrderStatus;
import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.persistence.*;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.ToString;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

@Entity
@Table(name = "orders")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(of = "id")
@ToString(exclude = {"user", "items"})
@Schema(description = "Entity representing an order in the system")
public class Order {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    @Schema(description = "Unique order ID automatically generated by the system", example = "a1b2c3d4-e5f6-7890-abcd-ef1234567890", accessMode = Schema.AccessMode.READ_ONLY)
    private UUID id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    @Schema(description = "Data of the user who placed the order", implementation = User.class)
    private User user;

    @NotNull
    @Column(name = "total_value", nullable = false, precision = 10, scale = 2)
    @Schema(description = "Total order value calculated automatically based on items", example = "7249.98", required = true)
    private BigDecimal totalValue;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    @Schema(
        description = "Current order status in the processing flow. PENDENTE: awaiting payment; PAGO: payment confirmed and stock reduced; CANCELADO: order cancelled due to insufficient stock or other reason",
        example = "PENDENTE",
        allowableValues = {"PENDENTE", "PAGO", "CANCELADO"},
        required = true
    )
    private OrderStatus status;

    @Column(name = "created_at", nullable = false)
    @JsonProperty(access = JsonProperty.Access.READ_ONLY)
    @Schema(description = "Order creation date and time (automatically generated)", example = "2025-01-15T10:23:45", accessMode = Schema.AccessMode.READ_ONLY)
    private LocalDateTime createdAt;

    @Column(name = "updated_at", nullable = false)
    @JsonProperty(access = JsonProperty.Access.READ_ONLY)
    @Schema(description = "Last update date and time (automatically updated)", example = "2025-01-15T14:37:22", accessMode = Schema.AccessMode.READ_ONLY)
    private LocalDateTime updatedAt;

    @Column(name = "payment_date")
    @JsonProperty(access = JsonProperty.Access.READ_ONLY)
    @Schema(description = "Date and time when payment was confirmed (null if not yet paid)", example = "2025-01-15T14:37:22", nullable = true, accessMode = Schema.AccessMode.READ_ONLY)
    private LocalDateTime paymentDate;

    // IDEMPOTENCY: Prevents duplicate order creation from double-clicks or network retries
    @Column(name = "idempotency_key", length = 100)
    @JsonProperty(access = JsonProperty.Access.READ_ONLY)
    @Schema(description = "Idempotency key to prevent order duplication", accessMode = Schema.AccessMode.READ_ONLY)
    private String idempotencyKey;

    @OneToMany(mappedBy = "order", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    @JsonIgnore
    @Schema(description = "List of items included in this order with their quantities and prices", accessMode = Schema.AccessMode.READ_ONLY)
    private List<OrderItem> items = new ArrayList<>();

    public Order(User user) {
        this.user = user;
        this.status = OrderStatus.PENDENTE;
        this.totalValue = BigDecimal.ZERO;
    }

    public Order(User user, String idempotencyKey) {
        this(user);
        this.idempotencyKey = idempotencyKey;
    }

    @PrePersist
    public void prePersist() {
        LocalDateTime now = LocalDateTime.now();
        if (this.createdAt == null) {
            this.createdAt = now;
        }
        this.updatedAt = now;
    }

    @PreUpdate
    public void preUpdate() {
        this.updatedAt = LocalDateTime.now();
    }

    public void addItem(OrderItem item) {
        items.add(item);
        item.setOrder(this);
        recalculateTotal();
    }

    public void removeItem(OrderItem item) {
        items.remove(item);
        item.setOrder(null);
        recalculateTotal();
    }

    public void recalculateTotal() {
        this.totalValue = items.stream()
                .map(item -> item.getUnitPrice().multiply(BigDecimal.valueOf(item.getQuantity())))
                .reduce(BigDecimal.ZERO, BigDecimal::add);
    }

    public void markAsPaid() {
        this.status = OrderStatus.PAGO;
        this.paymentDate = LocalDateTime.now();
    }

    public void markAsCancelled() {
        this.status = OrderStatus.CANCELADO;
    }
}